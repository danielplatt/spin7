from itertools import combinations, combinations_with_replacement, product
from log import get_logger
import math
from numpy import isclose


log = get_logger(__name__, level='WARNING')


class SingularSet:
    '''
    For example: vector_representation = [NaN, NaN, NaN, NaN, 0, 0, 0, 0]
    '''
    def __init__(self, vector_representation):
        self.vector_representation = vector_representation

    def generate_example(self):
        ex = self.vector_representation[:]
        for k in range(len(ex)):
            if math.isnan(ex[k]):
                ex[k] = 0.01
        return ex

    def is_in_set(self, x):
        for k in range(len(x)):
            if not math.isnan(self.vector_representation[k]):
                if not isclose(x[k], self.vector_representation[k], atol=0.001, equal_nan=True):
                    # print('%s : %s' % (x[k], self.vector_representation[k]))
                    return False
        return True


class TorusTransformations:
    @staticmethod
    def alpha(x):
        return [
            -x[0], -x[1], -x[2], -x[3], x[4], x[5], x[6], x[7]
        ]

    @staticmethod
    def beta(x):
        return [
            x[0], x[1], x[2], x[3], -x[4], -x[5], -x[6], -x[7]
        ]

    @staticmethod
    def gamma(x):
        return [
            1./2-x[0], 1./2-x[1], x[2], x[3], 1./2-x[4], 1./2-x[5], x[6], x[7]
        ]

    @staticmethod
    def delta(x):
        return [
            -x[0], x[1], 1./2-x[2], x[3], -x[4], x[5], 1./2-x[6], x[7]
        ]

    @staticmethod
    def tau(i, x):
        y = x[:]
        y[i] = y[i]+1
        return y

def check_if_composite(f, maps, depth):
    for k in range(depth):
        for comb in product(maps, repeat=k):
            # print(comb)
            x0 = [0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01]
            x = x0[:]
            for atom in f:
                x = eval('TorusTransformations.' + atom)
            y = x[:]
            x = x0[:]
            for func in comb:
                for atom in func:
                    # print('### %s' % (atom,))
                    x = eval('TorusTransformations.' + atom)
            # print((x,y))
            if all(isclose(x, y, atol=0.001, equal_nan=True)):
                log.info('f is composite. %s = %s' % (f, comb))
                return True
    log.info('f is not composite. f = %s ' % (f,))
    return False


if __name__ == '__main__':
    nan = float('nan')

    # Define singular sets in T^8 according to the list in p.369, Lemma 14.2.2 in Joyce's book
    S = [
        SingularSet([0, 0, 0, 0, nan, nan, nan, nan]),
        SingularSet([0, 0, 0, 1./2, nan, nan, nan, nan]),
        SingularSet([0, 1./2, 0, 0, nan, nan, nan, nan]),
        SingularSet([0, 1./2, 0, 1./2, nan, nan, nan, nan]),
        #
        SingularSet([nan, nan, nan, nan, 0, 0, 0, 0]),
        SingularSet([nan, nan, nan, nan, 0, 0, 0, 1./2]),
        SingularSet([nan, nan, nan, nan, 1./2, 0, 0, 0]),
        SingularSet([nan, nan, nan, nan, 1./2, 0, 0, 1./2]),
        #
        SingularSet([1./4, 1./4, nan, nan, 1./4, 1./4, nan, nan]),
        SingularSet([1./4, 1./4, nan, nan, 1./4, 3./4, nan, nan]),
        #
        SingularSet([0, nan, 1./4, nan, 0, nan, 1./4, nan]),
        SingularSet([0, nan, 1./4, nan, 1./2, nan, 1./4, nan]),
    ]

    maps = [
        'alpha(x)', 'beta(x)', 'gamma(x)', 'delta(x)', 'tau(0,x)', 'tau(1,x)', 'tau(2,x)',
        'tau(3,x)', 'tau(4,x)', 'tau(5,x)', 'tau(6,x)', 'tau(7,x)'
    ]
    print('Find all elements in Deck(T9) which can be written as the product of 3 or less of the maps %s.' % (maps))

    for sing_number in range(12):
        deck = []
        print('Analysing singular set S%s' % (sing_number,))
        for k in range(6):
            for comb in product(maps, repeat=k):
                x = S[sing_number].generate_example()
                # print('1: %s' % (x,))
                for func in comb:
                    x = eval('TorusTransformations.' + func)
                # print('2: %s' % (x,))
                if S[sing_number].is_in_set(x):
                    if not check_if_composite(comb, deck, k+1):
                        log.info('New non-composite deck transformation found: %s' % (comb,))
                        if len(comb)>1:
                            print('New non-composite deck transformation found: %s' % (comb,))
                            print(deck)
                        # print('%s: %s' % (comb, S9.is_in_set(x)))
                        deck += [comb]
        print('Set of deck transformations is generated by: %s' % (deck,))
